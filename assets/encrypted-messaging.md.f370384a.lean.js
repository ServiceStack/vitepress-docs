import{_ as n,c as e,o as s,a}from"./app.14440598.js";const g='{"title":"Encrypted Messaging","description":"","frontmatter":{"slug":"encrypted-messaging","title":"Encrypted Messaging"},"headers":[{"level":2,"title":"Encrypted Messaging Overview","slug":"encrypted-messaging-overview"},{"level":3,"title":"Configuration","slug":"configuration"},{"level":3,"title":"Generate a new Private Key","slug":"generate-a-new-private-key"},{"level":3,"title":"Giving Clients the Public Key","slug":"giving-clients-the-public-key"},{"level":2,"title":"Encrypted Service Client","slug":"encrypted-service-client"},{"level":3,"title":"Authentication with Encrypted Messaging","slug":"authentication-with-encrypted-messaging"},{"level":3,"title":"Combined Authentication Strategy","slug":"combined-authentication-strategy"},{"level":3,"title":"BearerToken in Request DTOs","slug":"bearertoken-in-request-dtos"},{"level":3,"title":"RSA and AES Hybrid Encryption verified with HMAC SHA-256","slug":"rsa-and-aes-hybrid-encryption-verified-with-hmac-sha-256"},{"level":3,"title":"Support for versioning Private Keys with Key Rotations","slug":"support-for-versioning-private-keys-with-key-rotations"},{"level":3,"title":"Why Rotate Private Keys?","slug":"why-rotate-private-keys"},{"level":3,"title":"Source Code","slug":"source-code"}],"relativePath":"encrypted-messaging.md","lastUpdated":1634495307618}',t={},o=a(`__VP_STATIC_START__<p>One of the benefits of adopting a message-based design is being able to easily layer functionality and generically add value to all Services, we&#39;ve seen this recently with <a href="/auto-batched-requests.html">Auto Batched Requests</a> which automatically enables each Service to be batched and executed in a single HTTP Request. Similarly the new Encrypted Messaging feature enables a secure channel for all Services (inc Auto Batched Requests \u{1F603} offering protection to clients who can now easily send and receive encrypted messages over unsecured HTTP!</p><h2 id="encrypted-messaging-overview" tabindex="-1">Encrypted Messaging Overview <a class="header-anchor" href="#encrypted-messaging-overview" aria-hidden="true">#</a></h2><p><img src="https://raw.githubusercontent.com/ServiceStack/Assets/master/img/release-notes/encrypted-messaging.png" alt=""></p><h3 id="configuration" tabindex="-1">Configuration <a class="header-anchor" href="#configuration" aria-hidden="true">#</a></h3><p>Encrypted Messaging support is enabled by registering the plugin:</p><div class="language-csharp"><pre><code>Plugins<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token constructor-invocation class-name">EncryptedMessagesFeature</span> <span class="token punctuation">{</span>
    PrivateKeyXml <span class="token operator">=</span> ServerRsaPrivateKeyXml
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>Where <code>PrivateKeyXml</code> is the Servers RSA Private Key Serialized as XML.</p><h3 id="generate-a-new-private-key" tabindex="-1">Generate a new Private Key <a class="header-anchor" href="#generate-a-new-private-key" aria-hidden="true">#</a></h3><p>If you don&#39;t have an existing one, a new one can be generated with:</p><div class="language-csharp"><pre><code><span class="token class-name"><span class="token keyword">var</span></span> rsaKeyPair <span class="token operator">=</span> RsaUtils<span class="token punctuation">.</span><span class="token function">CreatePublicAndPrivateKeyPair</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name"><span class="token keyword">string</span></span> ServerRsaPrivateKeyXml <span class="token operator">=</span> rsaKeyPair<span class="token punctuation">.</span>PrivateKey<span class="token punctuation">;</span>
</code></pre></div><p>Once generated, it&#39;s important the Private Key is kept confidential as anyone with access will be able to decrypt the encrypted messages! Whilst most <a href="http://stackoverflow.com/a/6018247/85785" target="_blank" rel="noopener noreferrer">obfuscation efforts are ultimately futile</a> the goal should be to contain the private key to your running Web Application, limiting access as much as possible.</p><p>Once registered, the EncryptedMessagesFeature enables the 2 Services below:</p><ul><li><code>GetPublicKey</code> - Returns the Serialized XML of your Public Key (extracted from the configured Private Key)</li><li><code>EncryptedMessage</code> - The Request DTO which encapsulates all encrypted Requests (can&#39;t be called directly)</li></ul><h3 id="giving-clients-the-public-key" tabindex="-1">Giving Clients the Public Key <a class="header-anchor" href="#giving-clients-the-public-key" aria-hidden="true">#</a></h3><p>To communicate clients need access to the Server&#39;s Public Key, it doesn&#39;t matter who has accessed the Public Key only that clients use the <strong>real</strong> Servers Public Key. It&#39;s therefore not advisable to download the Public Key over unsecure <code>http://</code> where traffic can potentially be intercepted and the key spoofed, subjecting them to a <a href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack" target="_blank" rel="noopener noreferrer">Man-in-the-middle attack</a>.</p><p>It&#39;s safer instead to download the public key over a trusted <code>https://</code> url where the servers origin is verified by a trusted <a href="https://en.wikipedia.org/wiki/Certificate_authority" target="_blank" rel="noopener noreferrer">CA</a>. Sharing the Public Key over Dropbox, Google Drive, OneDrive or other encrypted channels are also good options.</p><p>Since <code>GetPublicKey</code> is just a ServiceStack Service it&#39;s easily downloadable using a Service Client:</p><div class="language-csharp"><pre><code><span class="token class-name"><span class="token keyword">var</span></span> client <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">JsonServiceClient</span><span class="token punctuation">(</span>BaseUrl<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name"><span class="token keyword">string</span></span> publicKeyXml <span class="token operator">=</span> client<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token constructor-invocation class-name">GetPublicKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>If the registered <code>EncryptedMessagesFeature.PublicKeyPath</code> has been changed from its default <code>/publickey</code>, it can be dowloaded with:</p><div class="language-csharp"><pre><code><span class="token class-name"><span class="token keyword">string</span></span> publicKeyXml <span class="token operator">=</span> client<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">Get</span><span class="token generic class-name"><span class="token punctuation">&lt;</span><span class="token keyword">string</span><span class="token punctuation">&gt;</span></span></span><span class="token punctuation">(</span><span class="token string">&quot;/my-publickey&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//or with HttpUtils</span>
<span class="token class-name"><span class="token keyword">string</span></span> publicKeyXml <span class="token operator">=</span> BaseUrl<span class="token punctuation">.</span><span class="token function">CombineWith</span><span class="token punctuation">(</span><span class="token string">&quot;/my-publickey&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">GetStringFromUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><div class="info custom-block"><p class="custom-block-title">INFO</p><p>To help with verification the SHA256 Hash of the PublicKey is returned in <code>X-PublicKey-Hash</code> HTTP Header</p></div><h2 id="encrypted-service-client" tabindex="-1">Encrypted Service Client <a class="header-anchor" href="#encrypted-service-client" aria-hidden="true">#</a></h2><p>Once they have the Server&#39;s Public Key, clients can use it to get an <code>EncryptedServiceClient</code> via the <code>GetEncryptedClient()</code> extension method on <code>JsonServiceClient</code> or new <code>JsonHttpClient</code>, e.g:</p><div class="language-csharp"><pre><code><span class="token class-name"><span class="token keyword">var</span></span> client <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">JsonServiceClient</span><span class="token punctuation">(</span>BaseUrl<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">IEncryptedClient</span> encryptedClient <span class="token operator">=</span> client<span class="token punctuation">.</span><span class="token function">GetEncryptedClient</span><span class="token punctuation">(</span>publicKeyXml<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>Once configured, clients have access to the familiar typed Service Client API&#39;s and productive workflow they&#39;re used to with the generic Service Clients, sending typed Request DTO&#39;s and returning the typed Response DTO&#39;s - rendering the underlying encrypted messages a transparent implementation detail:</p><div class="language-csharp"><pre><code><span class="token class-name">HelloResponse</span> response <span class="token operator">=</span> encryptedClient<span class="token punctuation">.</span><span class="token function">Send</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token constructor-invocation class-name">Hello</span> <span class="token punctuation">{</span> Name <span class="token operator">=</span> <span class="token string">&quot;World&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
response<span class="token punctuation">.</span>Result<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//Hello, World!</span>
</code></pre></div><p>REST Services Example:</p><div class="language-csharp"><pre><code><span class="token class-name">HelloResponse</span> response <span class="token operator">=</span> encryptedClient<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token constructor-invocation class-name">Hello</span> <span class="token punctuation">{</span> Name <span class="token operator">=</span> <span class="token string">&quot;World&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>Auto-Batched Requests Example:</p><div class="language-csharp"><pre><code><span class="token class-name"><span class="token keyword">var</span></span> requests <span class="token operator">=</span> <span class="token keyword">new</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token string">&quot;Foo&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Bar&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Baz&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">Map</span><span class="token punctuation">(</span>x <span class="token operator">=&gt;</span> 
    <span class="token keyword">new</span> <span class="token constructor-invocation class-name">HelloSecure</span> <span class="token punctuation">{</span> Name <span class="token operator">=</span> x <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name"><span class="token keyword">var</span></span> responses <span class="token operator">=</span> encryptedClient<span class="token punctuation">.</span><span class="token function">SendAll</span><span class="token punctuation">(</span>requests<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>When using the <code>IEncryptedClient</code>, the entire Request and Response bodies are encrypted including Exceptions which continue to throw a populated <code>WebServiceException</code>:</p><div class="language-csharp"><pre><code><span class="token keyword">try</span>
<span class="token punctuation">{</span>
    <span class="token class-name"><span class="token keyword">var</span></span> response <span class="token operator">=</span> encryptedClient<span class="token punctuation">.</span><span class="token function">Send</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token constructor-invocation class-name">Hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">WebServiceException</span> ex<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    ex<span class="token punctuation">.</span>ResponseStatus<span class="token punctuation">.</span>ErrorCode<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//= ArgumentNullException</span>
    ex<span class="token punctuation">.</span>ResponseStatus<span class="token punctuation">.</span>Message<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//= Value cannot be null. </span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="authentication-with-encrypted-messaging" tabindex="-1">Authentication with Encrypted Messaging <a class="header-anchor" href="#authentication-with-encrypted-messaging" aria-hidden="true">#</a></h3><p>Many encrypted messaging solutions use Client Certificates which Servers can use to cryptographically verify a client&#39;s identity - providing an alternative to HTTP-based Authentication. We&#39;ve decided against using this as it would&#39;ve forced an opinionated implementation and increased burden of PKI certificate management and configuration onto Clients and Servers - reducing the applicability and instant utility of this feature.</p><p>We can instead leverage the existing Session-based Authentication Model in ServiceStack letting clients continue to use the existing Auth functionality and Auth Providers they&#39;re already used to, e.g:</p><div class="language-csharp"><pre><code><span class="token class-name"><span class="token keyword">var</span></span> authResponse <span class="token operator">=</span> encryptedClient<span class="token punctuation">.</span><span class="token function">Send</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token constructor-invocation class-name">Authenticate</span> <span class="token punctuation">{</span>
    provider <span class="token operator">=</span> CredentialsAuthProvider<span class="token punctuation">.</span>Name<span class="token punctuation">,</span>
    UserName <span class="token operator">=</span> <span class="token string">&quot;test@gmail.com&quot;</span><span class="token punctuation">,</span>
    Password <span class="token operator">=</span> <span class="token string">&quot;p@55w0rd&quot;</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>Encrypted Messages have their cookies stripped so they&#39;re no longer visible in the clear which minimizes their exposure to Session hijacking. This does pose the problem of how we can call authenticated Services if the encrypted HTTP Client is no longer sending Session Cookies?</p><p>Without the use of clear-text Cookies or HTTP Headers there&#39;s no longer an <em>established Authenticated Session</em> for the <code>encryptedClient</code> to use to make subsequent Authenticated requests. What we can do instead is pass the Session Id in the encrypted body for Request DTO&#39;s that implement the new <code>IHasSessionId</code> interface, e.g:</p><div class="language-csharp"><pre><code><span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">Authenticate</span></span><span class="token punctuation">]</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloAuthenticated</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">IReturn<span class="token punctuation">&lt;</span>HelloAuthenticatedResponse<span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> 
    <span class="token class-name">IHasSessionId</span></span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">string</span></span> SessionId <span class="token punctuation">{</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">string</span></span> Name <span class="token punctuation">{</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token class-name"><span class="token keyword">var</span></span> response <span class="token operator">=</span> encryptedClient<span class="token punctuation">.</span><span class="token function">Send</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token constructor-invocation class-name">HelloAuthenticated</span> <span class="token punctuation">{</span>
    SessionId <span class="token operator">=</span> authResponse<span class="token punctuation">.</span>SessionId<span class="token punctuation">,</span>
    Name <span class="token operator">=</span> <span class="token string">&quot;World&quot;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>Here we&#39;re injecting the returned Authenticated <code>SessionId</code> to access the <code>[Authenticate]</code> protected Request DTO. However remembering to do this for every authenticated request can get tedious, a nicer alternative is just setting it once on the <code>encryptedClient</code> which will then use it to automatically populate any <code>IHasSessionId</code> Request DTO&#39;s:</p><div class="language-csharp"><pre><code>encryptedClient<span class="token punctuation">.</span>SessionId <span class="token operator">=</span> authResponse<span class="token punctuation">.</span>SessionId<span class="token punctuation">;</span>

<span class="token class-name"><span class="token keyword">var</span></span> response <span class="token operator">=</span> encryptedClient<span class="token punctuation">.</span><span class="token function">Send</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token constructor-invocation class-name">HelloAuthenticated</span> <span class="token punctuation">{</span>
    Name <span class="token operator">=</span> <span class="token string">&quot;World&quot;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><div class="info custom-block"><p class="custom-block-title">INFO</p><p>This feature is now supported in <strong>all Service Clients</strong></p></div><h3 id="combined-authentication-strategy" tabindex="-1">Combined Authentication Strategy <a class="header-anchor" href="#combined-authentication-strategy" aria-hidden="true">#</a></h3><p>Another potential use-case is to only use Encrypted Messaging when sending any sensitive information and the normal Service Client for other requests. In which case we can Authenticate and send the user&#39;s password with the <code>encryptedClient</code>:</p><div class="language-csharp"><pre><code><span class="token class-name"><span class="token keyword">var</span></span> authResponse <span class="token operator">=</span> encryptedClient<span class="token punctuation">.</span><span class="token function">Send</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token constructor-invocation class-name">Authenticate</span> <span class="token punctuation">{</span>
    provider <span class="token operator">=</span> CredentialsAuthProvider<span class="token punctuation">.</span>Name<span class="token punctuation">,</span>
    UserName <span class="token operator">=</span> <span class="token string">&quot;test@gmail.com&quot;</span><span class="token punctuation">,</span>
    Password <span class="token operator">=</span> <span class="token string">&quot;p@55w0rd&quot;</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>But then fallback to using the normal <code>IServiceClient</code> for subsequent requests. But as the <code>encryptedClient</code> doesn&#39;t receive cookies we&#39;d need to set it explicitly on the client ourselves with:</p><div class="language-csharp"><pre><code>client<span class="token punctuation">.</span><span class="token function">SetSessionId</span><span class="token punctuation">(</span>authResponse<span class="token punctuation">.</span>SessionId<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//Equivalent to:</span>
client<span class="token punctuation">.</span><span class="token function">SetCookie</span><span class="token punctuation">(</span><span class="token string">&quot;ss-id&quot;</span><span class="token punctuation">,</span> authResponse<span class="token punctuation">.</span>SessionId<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>After which the ServiceClient &quot;establishes an authenticated session&quot; and can be used to make Authenticated requests, e.g:</p><div class="language-csharp"><pre><code><span class="token class-name"><span class="token keyword">var</span></span> response <span class="token operator">=</span> <span class="token keyword">await</span> client<span class="token punctuation">.</span><span class="token function">GetAsync</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token constructor-invocation class-name">HelloAuthenticated</span> <span class="token punctuation">{</span> Name <span class="token operator">=</span> <span class="token string">&quot;World&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="bearertoken-in-request-dtos" tabindex="-1">BearerToken in Request DTOs <a class="header-anchor" href="#bearertoken-in-request-dtos" aria-hidden="true">#</a></h3><p>Similar to the <code>IHasSessionId</code> interface Request DTOs can also implement <code>IHasBearerToken</code> to send Bearer Tokens as an alternative for sending them in HTTP Headers or Cookies.</p><p>This lets you authenticate with Auth Providers like <a href="/api-key-authprovider.html">API Key</a> and <a href="/jwt-authprovider.html">JWT</a> in <a href="/encrypted-messaging.html">Encrypted Messaging</a> requests, e.g:</p><div class="language-csharp"><pre><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Secure</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">IHasBearerToken</span></span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">string</span></span> BearerToken <span class="token punctuation">{</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">string</span></span> Name <span class="token punctuation">{</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token class-name">IEncryptedClient</span> encryptedClient <span class="token operator">=</span> client<span class="token punctuation">.</span><span class="token function">GetEncryptedClient</span><span class="token punctuation">(</span>publicKey<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name"><span class="token keyword">var</span></span> response <span class="token operator">=</span> encryptedClient<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token constructor-invocation class-name">Secure</span> <span class="token punctuation">{</span> BearerToken <span class="token operator">=</span> apiKey<span class="token punctuation">,</span> Name <span class="token operator">=</span> <span class="token string">&quot;World&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>Where it will be embedded and encrypted along with all content in the Request DTO so it can be sent securely over an unsecured HTTP Request.</p><p>Alternatively you can set the <code>BearerToken</code> property on the <code>IEncryptedClient</code> once where it will automatically populate all Request DTOs that implement <code>IHasBearerToken</code>, e.g:</p><div class="language-csharp"><pre><code>encryptedClient<span class="token punctuation">.</span>BearerToken <span class="token operator">=</span> apiKey<span class="token punctuation">;</span>

<span class="token class-name"><span class="token keyword">var</span></span> response <span class="token operator">=</span> encryptedClient<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token constructor-invocation class-name">Secure</span> <span class="token punctuation">{</span> Name <span class="token operator">=</span> <span class="token string">&quot;World&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="rsa-and-aes-hybrid-encryption-verified-with-hmac-sha-256" tabindex="-1">RSA and AES Hybrid Encryption verified with HMAC SHA-256 <a class="header-anchor" href="#rsa-and-aes-hybrid-encryption-verified-with-hmac-sha-256" aria-hidden="true">#</a></h3><p>The Encrypted Messaging Feature follows a <a href="https://en.wikipedia.org/wiki/Hybrid_cryptosystem" target="_blank" rel="noopener noreferrer">Hybrid Cryptosystem</a> which uses RSA Public Keys for <a href="https://en.wikipedia.org/wiki/Public-key_cryptography" target="_blank" rel="noopener noreferrer">Asymmetric Encryption</a> combined with the performance of AES <a href="https://en.wikipedia.org/wiki/Symmetric-key_algorithm" target="_blank" rel="noopener noreferrer">Symmetric Encryption</a> making it suitable for encrypting large message payloads. The authenticity of Encrypted Data are then verified with HMAC SHA-256, essentially following an <a href="http://crypto.stackexchange.com/a/205/25652" target="_blank" rel="noopener noreferrer">Encrypt-then-MAC strategy</a>.</p><p>The key steps in the process are outlined below:</p><ol><li>Client creates a new <code>IEncryptedClient</code> configured with the Server <strong>Public Key</strong></li><li>Client uses the <code>IEncryptedClient</code> to create a EncryptedMessage Request DTO: <ol><li>Generates a new AES 256bit/CBC/PKCS7 Crypt Key <strong>(Kc)</strong>, Auth Key <strong>(Ka)</strong> and <strong>IV</strong></li><li>Encrypts Crypt Key <strong>(Kc)</strong>, Auth Key <strong>(Ka)</strong> with Servers Public Key padded with OAEP = <strong>(Kc+Ka+P)e</strong></li><li>Authenticates <strong>(Kc+Ka+P)e</strong> with <strong>IV</strong> using HMAC SHA-256 = <strong>IV+(Kc+Ka+P)e+Tag</strong></li><li>Serializes Request DTO to JSON packed with current <code>Timestamp</code>, <code>Verb</code> and <code>Operation</code> = <strong>(M)</strong></li><li>Encrypts <strong>(M)</strong> with Crypt Key <strong>(Kc)</strong> and <strong>IV</strong> = <strong>(M)e</strong></li><li>Authenticates <strong>(M)e</strong> with Auth Key <strong>(Ka)</strong> and <strong>IV</strong> = <strong>IV+(M)e+Tag</strong></li><li>Creates <code>EncryptedMessage</code> DTO with Servers <code>KeyId</code>, <strong>IV+(Kc+Ka+P)e+Tag</strong> and <strong>IV+(M)e+Tag</strong></li></ol></li><li>Client uses the <code>IEncryptedClient</code> to send the populated <code>EncryptedMessage</code> to the remote Server</li></ol><p>On the Server, the <code>EncryptedMessagingFeature</code> Request Converter processes the <code>EncryptedMessage</code> DTO:</p><ol><li>Uses Private Key identified by <strong>KeyId</strong> or the current Private Key if <strong>KeyId</strong> wasn&#39;t provided <ol><li>Request Converter Extracts <strong>IV+(Kc+Ka+P)e+Tag</strong> into <strong>IV</strong> and <strong>(Kc+Ka+P)e+Tag</strong></li><li>Decrypts <strong>(Kc+Ka+P)e+Tag</strong> with Private Key into <strong>(Kc)</strong> and <strong>(Ka)</strong></li><li>The <strong>IV</strong> is checked against the nonce Cache, verified it&#39;s never been used before, then cached</li><li>The <strong>IV+(Kc+Ka+P)e+Tag</strong> is verified it hasn&#39;t been tampered with using Auth Key <strong>(Ka)</strong></li><li>The <strong>IV+(M)e+Tag</strong> is verified it hasn&#39;t been tampered with using Auth Key <strong>(Ka)</strong></li><li>The <strong>IV+(M)e+Tag</strong> is decrypted using Crypt Key <strong>(Kc)</strong> = <strong>(M)</strong></li><li>The <strong>timestamp</strong> is verified it&#39;s not older than <code>EncryptedMessagingFeature.MaxRequestAge</code></li><li>Any expired nonces are removed. (The <strong>timestamp</strong> and <strong>IV</strong> are used to prevent replay attacks)</li><li>The JSON body is deserialized and resulting <strong>Request DTO</strong> returned from the Request Converter</li></ol></li><li>The converted <strong>Request DTO</strong> is executed in ServiceStack&#39;s Request Pipeline as normal</li><li>The <strong>Response DTO</strong> is picked up by the EncryptedMessagingFeature <strong>Response Converter</strong>: <ol><li>Any <strong>Cookies</strong> set during the Request are removed</li><li>The <strong>Response DTO</strong> is serialized with the <strong>AES Key</strong> and returned in an <code>EncryptedMessageResponse</code></li></ol></li><li>The <code>IEncryptedClient</code> decrypts the <code>EncryptedMessageResponse</code> with the <strong>AES Key</strong><ol><li>The <strong>Response DTO</strong> is extracted and returned to the caller</li></ol></li></ol><p>A visual of how this all fits together in captured in the high-level diagram below:</p><p><img src="https://raw.githubusercontent.com/ServiceStack/Assets/master/img/release-notes/encrypted-messaging.png" alt=""></p><ul><li>Components in <strong>Yellow</strong> show the encapsulated Encrypted Messaging functionality where all encryption and decryption is performed</li><li>Components in <strong>Blue</strong> show Unencrypted DTO&#39;s</li><li>Components in <strong>Green</strong> show Encrypted content: <ul><li>The AES Keys and IV in <strong>Dark Green</strong> is encrypted by the client using the Server&#39;s Public Key</li><li>The EncryptedRequest in <strong>Light Green</strong> is encrypted with a new AES Key generated by the client on each Request</li></ul></li><li>Components in <strong>Dark Grey</strong> depict existing ServiceStack functionality where Requests are executed as normal through the <a href="/csharp-client.html">Service Client</a> and <a href="/order-of-operations.html">Request Pipeline</a></li></ul><p>All Request and Response DTO&#39;s get encrypted and embedded in the <code>EncryptedMessage</code> and <code>EncryptedMessageResponse</code> DTO&#39;s below:</p><div class="language-csharp"><pre><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EncryptedMessage</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">IReturn<span class="token punctuation">&lt;</span>EncryptedMessageResponse<span class="token punctuation">&gt;</span></span></span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">string</span></span> KeyId <span class="token punctuation">{</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">string</span></span> EncryptedSymmetricKey <span class="token punctuation">{</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">string</span></span> EncryptedBody <span class="token punctuation">{</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EncryptedMessageResponse</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">string</span></span> EncryptedBody <span class="token punctuation">{</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>The diagram also expands the <code>EncryptedBody</code> Content containing the <strong>EncryptedRequest</strong> consisting of the following parts:</p><ul><li><strong>Timestamp</strong> - Unix Timestamp of the Request</li><li><strong>Verb</strong> - Target HTTP Method</li><li><strong>Operation</strong> - Request DTO Name</li><li><strong>JSON</strong> - Request DTO serialized as JSON</li></ul><h3 id="support-for-versioning-private-keys-with-key-rotations" tabindex="-1">Support for versioning Private Keys with Key Rotations <a class="header-anchor" href="#support-for-versioning-private-keys-with-key-rotations" aria-hidden="true">#</a></h3><p>One artifact visible in the above process was the use of a <code>KeyId</code>. This is a human readable string used to identify the Servers Public Key using the first 7 characters of the Public Key Modulus (visible when viewing the Private Key serialized as XML). This is automatically sent by <code>IEncryptedClient</code> to tell the <code>EncryptedMessagingFeature</code> which Private Key should be used to decrypt the AES Crypt and Auth Keys.</p><p>By supporting multiple private keys, the Encrypted Messaging feature allows the seamless transition to a new Private Key without affecting existing clients who have yet to adopt the latest Public Key.</p><p>Transitioning to a new Private Key just involves taking the existing Private Key and adding it to the <code>FallbackPrivateKeys</code> collection whilst introducing a new Private Key, e.g:</p><div class="language-csharp"><pre><code>Plugins<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token constructor-invocation class-name">EncryptedMessagesFeature</span>
<span class="token punctuation">{</span>
    PrivateKey <span class="token operator">=</span> NewPrivateKey<span class="token punctuation">,</span>
    FallbackPrivateKeys <span class="token operator">=</span> <span class="token punctuation">{</span>
        PreviousKey2015<span class="token punctuation">,</span>
        PreviousKey2014<span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="why-rotate-private-keys" tabindex="-1">Why Rotate Private Keys? <a class="header-anchor" href="#why-rotate-private-keys" aria-hidden="true">#</a></h3><p>Since anyone who has a copy of the Private Key can decrypt encrypted messages, rotating the private key clients use limits the amount of exposure an adversary who has managed to get a hold of a compromised private key has. i.e. if the current Private Key was somehow compromised, an attacker with access to the encrypted network packets will be able to read each message sent that was encrypted with the compromised private key up until the Server introduces a new Private Key which clients switches over to.</p><h3 id="source-code" tabindex="-1">Source Code <a class="header-anchor" href="#source-code" aria-hidden="true">#</a></h3><ul><li>The Client implementation is available in <a href="https://github.com/ServiceStack/ServiceStack/blob/master/src/ServiceStack.Client/EncryptedServiceClient.cs" target="_blank" rel="noopener noreferrer">EncryptedServiceClient.cs</a></li><li>The Server implementation is available in <a href="https://github.com/ServiceStack/ServiceStack/blob/master/src/ServiceStack/EncryptedMessagesFeature.cs" target="_blank" rel="noopener noreferrer">EncryptedMessagesFeature.cs</a></li><li>The Crypto Utils used are available in the <a href="https://github.com/ServiceStack/ServiceStack/blob/3af2526d2f710576a9764d22501af428e85315cb/src/ServiceStack.Client/CryptUtils.cs#L31" target="_blank" rel="noopener noreferrer">RsaUtils.cs</a> and <a href="https://github.com/ServiceStack/ServiceStack/blob/3af2526d2f710576a9764d22501af428e85315cb/src/ServiceStack.Client/CryptUtils.cs#L198" target="_blank" rel="noopener noreferrer">AesUtils.cs</a></li><li>Tests are available in <a href="https://github.com/ServiceStack/ServiceStack/blob/master/tests/ServiceStack.WebHost.Endpoints.Tests/UseCases/EncryptedMessagesTests.cs" target="_blank" rel="noopener noreferrer">EncryptedMessagesTests.cs</a></li></ul>__VP_STATIC_END__`,78),p=[o];function c(i,r,l,u,d,k){return s(),e("div",null,p)}var y=n(t,[["render",c]]);export{g as __pageData,y as default};
