import{_ as e,c as t,o,a as n}from"./app.14440598.js";const m='{"title":"Deploy .NET Core with Docker to EC2 Container Service","description":"","frontmatter":{"slug":"deploy-netcore-docker-aws-ecs","title":"Deploy .NET Core with Docker to EC2 Container Service"},"headers":[{"level":2,"title":"Native Docker Integration in the Cloud","slug":"native-docker-integration-in-the-cloud"},{"level":2,"title":"AWS EC2 Container Service","slug":"aws-ec2-container-service"},{"level":2,"title":"Deploying to AWS Container Service Overview","slug":"deploying-to-aws-container-service-overview"},{"level":3,"title":"Deploying fork of redis-geo .NET Core App","slug":"deploying-fork-of-redis-geo-net-core-app"},{"level":3,"title":"Running build scripts locally","slug":"running-build-scripts-locally"},{"level":3,"title":"Walkthrough Overview","slug":"walkthrough-overview"},{"level":2,"title":"1. Create the ecsInstanceRole Role","slug":"_1-create-the-ecsinstancerole-role"},{"level":2,"title":"2. Create a new IAM User","slug":"_2-create-a-new-iam-user"},{"level":2,"title":"Checkout AWS Container Service","slug":"checkout-aws-container-service"},{"level":2,"title":"3. Launch new EC2 Docker Server Instance","slug":"_3-launch-new-ec2-docker-server-instance"},{"level":2,"title":"Revisit AWS Container Service","slug":"revisit-aws-container-service"},{"level":2,"title":"4. Associating Elastic IP to new EC2 Instance","slug":"_4-associating-elastic-ip-to-new-ec2-instance"},{"level":2,"title":"Assign a Domain Name to your Elastic IP","slug":"assign-a-domain-name-to-your-elastic-ip"},{"level":2,"title":"5. Log into the new EC2 Instance","slug":"_5-log-into-the-new-ec2-instance"},{"level":3,"title":"Enable support for SSL","slug":"enable-support-for-ssl"},{"level":2,"title":"6. Fork redis-geo Demo","slug":"_6-fork-redis-geo-demo"},{"level":3,"title":"Inspect the Build Scripts","slug":"inspect-the-build-scripts"},{"level":3,"title":"ECS task-definition.json","slug":"ecs-task-definition-json"},{"level":2,"title":"Configure support for SSL","slug":"configure-support-for-ssl"},{"level":2,"title":"Create project in Travis-CI","slug":"create-project-in-travis-ci"},{"level":3,"title":"CI Environment Variables","slug":"ci-environment-variables"},{"level":2,"title":"Inspect AWS Container Service","slug":"inspect-aws-container-service"},{"level":3,"title":"View list of running Docker Containers","slug":"view-list-of-running-docker-containers"},{"level":2,"title":"Problems with the task not running","slug":"problems-with-the-task-not-running"},{"level":2,"title":"8. Play your deployed .NET Core Docker App!","slug":"_8-play-your-deployed-net-core-docker-app"},{"level":2,"title":"Things to try","slug":"things-to-try"},{"level":3,"title":"1. Make a change to your App","slug":"_1-make-a-change-to-your-app"},{"level":3,"title":"2. Go through this tutorial again","slug":"_2-go-through-this-tutorial-again"},{"level":3,"title":"3. Copy the build scripts to Dockerize own .NET Core Apps","slug":"_3-copy-the-build-scripts-to-dockerize-own-net-core-apps"},{"level":3,"title":"4. Exec build scripts to Create and Run your Docker App locally","slug":"_4-exec-build-scripts-to-create-and-run-your-docker-app-locally"}],"relativePath":"deploy-netcore-docker-aws-ecs.md","lastUpdated":1634495307618}',s={},r=n(`__VP_STATIC_START__<p><img src="https://docs.servicestack.net/images/aws/ecs/ecs-banner.png" alt=""></p><p>One of the primary benefits of <a href="https://www.microsoft.com/net/core" target="_blank" rel="noopener noreferrer">.NET Core&#39;s</a> first-class support for Linux is being able to leverage the thriving ecosystem that&#39;s formed around automating, deploying and hosting Server Apps on Linux. Whilst there have been a number of deployment strategies that have been adopted over the years, the current state-of-the-art is the standardization around the <a href="https://www.docker.com/" target="_blank" rel="noopener noreferrer">Docker container format</a> which hits the sweet spot of providing isolation within a minimal footprint over encapsulating your App and its dependencies which is contrast to including an entire Operating System when using VM&#39;s. In addition to being lightweight and efficient to run, Docker also enables fast, reproducible builds where your entire App&#39;s Image can be rebuilt by your CI Server on each check-in - bringing the same benefits of version control and continuous integration on your code to your Server infrastructure - which can now be easily be versioned, replicated, scaled and automated.</p><p>Once built, your Docker App is treated like an opaque Image where the fact it&#39;s running .NET Core instead of a pure LAMP stack becomes a transparent implementation detail that doesn&#39;t impact the utility of your App, who are both able to equally benefit from Docker&#39;s rich ecosystem. E.g. your Docker App can be uploaded to any public Docker repository where it can be easily shared and run on any <a href="https://docs.docker.com/engine/installation/linux/" target="_blank" rel="noopener noreferrer">supported Linux Distrobution</a>. In addition to being able to run any published Docker image on any Docker-enabled OS, you&#39;re also able to use it as a the source image for your own custom Docker Image, a feature that you&#39;ll take advantage of when building your own .NET Core Docker App which is based on Microsoft&#39;s <a href="https://hub.docker.com/r/microsoft/dotnet/" target="_blank" rel="noopener noreferrer">microsoft/dotnet</a> Docker Image that&#39;s published on <a href="https://hub.docker.com/explore/" target="_blank" rel="noopener noreferrer">Docker&#39;s public repository</a>.</p><h2 id="native-docker-integration-in-the-cloud" tabindex="-1">Native Docker Integration in the Cloud <a class="header-anchor" href="#native-docker-integration-in-the-cloud" aria-hidden="true">#</a></h2><p>As the premier Container format for packaging Server Apps, all major cloud providers include native support for Docker that goes beyond the basic hosting of Docker Images to also include repository management, monitoring, inspection and orchestration which lets you easily (or automatically) scale your Docker App on a managed cluster of VMs. You can learn more about the Docker integration offerings of the major Cloud providers in the links below:</p><ul><li><strong>AWS</strong> - <a href="https://aws.amazon.com/ecs/" target="_blank" rel="noopener noreferrer">Amazon EC2 Container Service</a></li><li><strong>Azure</strong> - <a href="https://azure.microsoft.com/en-us/services/container-service/" target="_blank" rel="noopener noreferrer">Azure Container Service</a></li><li><strong>Google Cloud</strong> - <a href="https://cloud.google.com/container-engine/" target="_blank" rel="noopener noreferrer">Google Container Engine</a></li></ul><p>Whilst other popular Cloud providers like <a href="https://www.digitalocean.com" target="_blank" rel="noopener noreferrer">Digital Ocean</a> make it trivial to <a href="https://www.digitalocean.com/products/one-click-apps/docker/" target="_blank" rel="noopener noreferrer">setup a Docker Server in seconds</a>.</p><h2 id="aws-ec2-container-service" tabindex="-1">AWS EC2 Container Service <a class="header-anchor" href="#aws-ec2-container-service" aria-hidden="true">#</a></h2><p>For this guide we&#39;ll walk through how we&#39;ve deployed our <a href="https://github.com/NetCoreApps/LiveDemos" target="_blank" rel="noopener noreferrer">.NET Core Live Demos</a> using the popular power combo of:</p><ul><li>Using <a href="https://travis-ci.org/" target="_blank" rel="noopener noreferrer">travis-ci.org</a> (free for OSS projects) for running CI scripts to rebuild Docker App Images on every check-in</li><li>Using <a href="https://aws.amazon.com/ecs/" target="_blank" rel="noopener noreferrer">AWS EC2 Container Service</a> for managing Docker images and instance deployments</li><li>Using <a href="https://github.com/jwilder/nginx-proxy" target="_blank" rel="noopener noreferrer">nginx-proxy</a> setting up an nginx reverse proxy and automatically bind virtual hosts to Docker Instances</li></ul><p>We&#39;ll also look at covering <a href="https://azure.microsoft.com/en-us/services/container-service/" target="_blank" rel="noopener noreferrer">Azure Container Service</a> in future as it&#39;s another popular option for deploying and hosting .NET Core Docker Apps.</p><h2 id="deploying-to-aws-container-service-overview" tabindex="-1">Deploying to AWS Container Service Overview <a class="header-anchor" href="#deploying-to-aws-container-service-overview" aria-hidden="true">#</a></h2><p>In this guide we&#39;ll go through setting up your AWS Account to enable Docker deployments using AWS EC2 Container Service and have them deploy to a single EC2 Instance for optimal value and minimal cost. There&#39;s <a href="https://aws.amazon.com/ecs/pricing/" target="_blank" rel="noopener noreferrer">no additional cost for using AWS&#39;s EC2 Container Service</a> beyond the cost of the EBS and EC2 resources for storing and running your Docker Containers. Thanks to the small footprint of Docker Containers and .NET Core&#39;s lean profile you&#39;ll be able to host a few small Docker Apps on a <strong>T2 Micro</strong> instance costing less than <strong>&lt;$10 per month</strong> or if you haven&#39;t created an account with AWS before, you can run it <strong>free for 12 months</strong> courtesy of <a href="https://aws.amazon.com/free/" target="_blank" rel="noopener noreferrer">AWS Free Tier</a>.</p><h3 id="deploying-fork-of-redis-geo-net-core-app" tabindex="-1">Deploying fork of redis-geo .NET Core App <a class="header-anchor" href="#deploying-fork-of-redis-geo-net-core-app" aria-hidden="true">#</a></h3><p>We&#39;ll be deploying a fork of the .NET Core <a href="https://github.com/NetCoreApps/redis-geo" target="_blank" rel="noopener noreferrer">Redis GEO Live Demo</a> as it&#39;s a good representative of a small multi-project .NET Core solution that requires an external Redis Server infrastructure dependency which we&#39;ll deploy alongside our App in a separate Docker container.</p><p>We&#39;ll use <a href="https://travis-ci.org/" target="_blank" rel="noopener noreferrer">Travis CI</a> to do the actual build and deployments by running the plain bash scripts that lives alongside your code in the same <a href="https://github.com/NetCoreApps/redis-geo" target="_blank" rel="noopener noreferrer">Github Repo</a> which builds and deploys your Docker App. Most of the bash scripts are generic and can be reused for deploying different projects with only minor config changes to specify the solution to build and the AWS Account to deploy to, with any sensitive information maintained in Travis-CI private Environment Variables so they&#39;re kept out of the public Github repositories.</p><h3 id="running-build-scripts-locally" tabindex="-1">Running build scripts locally <a class="header-anchor" href="#running-build-scripts-locally" aria-hidden="true">#</a></h3><p>A nice property of using plain Bash scripts to build Docker images is being able to run them locally where you can run the resulting Docker Image natively on your Linux Dev or OSX workstation with <a href="https://docs.docker.com/engine/installation/mac/" target="_blank" rel="noopener noreferrer">Docker for Mac</a> which is nicely integrated courtesy of OS X&#39;s built-in Bash support. Whilst less integrated, there&#39;s also support for building and running Docker Images with <a href="https://docs.docker.com/docker-for-windows/" target="_blank" rel="noopener noreferrer">Docker for Windows</a>.</p><h3 id="walkthrough-overview" tabindex="-1">Walkthrough Overview <a class="header-anchor" href="#walkthrough-overview" aria-hidden="true">#</a></h3><p>The basic steps for deploy your .NET Core App with Docker that&#39;s covered in this guide include:</p><ol><li>Creating a <code>ecsInstanceRole</code> Role that your <strong>EC2 Instance</strong> will run as</li><li>Creating a <code>ecsDemoUser</code> User for remotely running AWS CLI utils to deploy to your AWS Account</li><li>Launching a new <strong>EC2 Instance</strong> with the <code>ecsInstanceRole</code> Role to use as your Docker Server</li><li>Configuring DNS and associating an <strong>Elastic IP</strong> to the new <strong>EC2 Instance</strong></li><li>SSH into the <strong>EC2 Instance</strong> to run the <code>nginx-proxy</code> Docker Container</li><li>Forking the <code>redis-geo</code> Github project</li><li>Configure <strong>Travis CI</strong> to deploy your <code>redis-geo</code> fork to your AWS ECS Service</li><li>Playing with your deployed .NET Core Docker App!</li></ol><p>Whilst this may seem like a lot of effort to deploy a Docker App, most of the above steps only need to be done once - only <strong>steps 6-8</strong> are repeatable for each new project that you want to deploy to your ECS Container EC2 Instance.</p><p>At the end of the rainbow an instance of <strong>your redis-geo fork</strong> .NET Core App will be running on your AWS <strong>EC2 Instance</strong>, re-deployed on every check-in by triggering <strong>Travis CI</strong> into action to rebuild and package the latest version of your App in a new Docker App Image that it also publishes to your ECS Service.</p><p>ECS also maintains a complete history of every Docker App Image and related task definition deployed in its private Docker Repository. ECS also lets you inspect your running EC2 Instance to see how much CPU and memory is used - providing valuable insight in how many more Docker Apps you&#39;ll be able to pack into your EC2 Instance.</p><p>Now we know what we&#39;re getting, let&#39;s jump in!</p><h2 id="_1-create-the-ecsinstancerole-role" tabindex="-1">1. Create the <code>ecsInstanceRole</code> Role <a class="header-anchor" href="#_1-create-the-ecsinstancerole-role" aria-hidden="true">#</a></h2><p>Our first port of call is to create a new <code>ecsInstanceRole</code> in IAM, this is a <a href="http://docs.aws.amazon.com/AmazonECS/latest/developerguide/instance_IAM_role.html" target="_blank" rel="noopener noreferrer">special Role for EC2 Container Instances</a> that contains the necessary permissions for your EC2 Instance to communicate with the ECS API.</p><p>When launching a new EC2 Instance with the <code>ecsInstanceRole</code>, it will automatically create the <strong>default cluster</strong> in ECS and registers itself to the set of EC2 instances that are available to run Docker Apps deployed to that cluster.</p><p>Creating new Roles are done within <strong>Identity &amp; Access Management (IAM)</strong> in your AWS dashboard under the <strong>Roles</strong> tab which you can jump directly to using the deep link: <a href="https://console.aws.amazon.com/iam/home#roles" target="_blank" rel="noopener noreferrer">https://console.aws.amazon.com/iam/home#roles</a>. Then click on <strong>Create New Role</strong> button to start the Create Role Wizard:</p><p>Type <code>ecsInstanceRole</code> for the <strong>Role Name</strong> then click <strong>Next Step</strong>:</p><p><img src="https://docs.servicestack.net/images/aws/ecs/role-01.png" alt=""></p><p>Select the <strong>Amazon EC2 Role for EC2 Container Service</strong> Role Type:</p><p><img src="https://docs.servicestack.net/images/aws/ecs/role-02.png" alt=""></p><p>You&#39;ll also need to attach the <code>AmazonEC2ContainerServiceforEC2Role</code> policy which you can quickly find by pasting it in the <strong>Policy Type</strong> filter and selecting the only result and proceeding to the <strong>Next Step</strong>:</p><p><img src="https://docs.servicestack.net/images/aws/ecs/role-03.png" alt=""></p><p>The last page in the Wizard lets you review details of the Role you&#39;ll creating after clicking <strong>Create Role</strong>:</p><p><img src="https://docs.servicestack.net/images/aws/ecs/role-04.png" alt=""></p><p>The new <code>ecsInstanceRole</code> will be available in the <strong>Roles</strong> tab which you can click on to open its Detail View:</p><p><img src="https://docs.servicestack.net/images/aws/ecs/role-05.png" alt=""></p><h2 id="_2-create-a-new-iam-user" tabindex="-1">2. Create a new IAM User <a class="header-anchor" href="#_2-create-a-new-iam-user" aria-hidden="true">#</a></h2><p>We now need to create a new User in IAM to allow remote Servers we want to access our ECS Container Service. <strong>Travis CI</strong> needs to authenticate as this User in order to use the <a href="https://aws.amazon.com/cli/" target="_blank" rel="noopener noreferrer">AWS CLI</a> utils so it can deploy our Docker App to our ECS <strong>default</strong> Cluster.</p><p>Similar to creating a role, to create a new User select the <strong>Users</strong> tab then click <strong>Create New Users</strong>. On the next screen add your preferred Username for this new User in the first textbox then click <strong>Create</strong>:</p><p><img src="https://docs.servicestack.net/images/aws/ecs/user-01.png" alt=""></p><p>You&#39;ll need to copy both the <strong>Access Key ID</strong> and <strong>Secret Access Key</strong> which is <strong>only available</strong> from the next screen. These credentials <strong>need to be saved</strong> as you&#39;ll need to configure it with <strong>Travis CI</strong> later so it can authenticate as this new User.</p><p><img src="https://docs.servicestack.net/images/aws/ecs/user-02.png" alt=""></p><p>We also need to assign the following permissions to the new User to give it access to our ECS Service. The easiest way to select these policies is to copy each into the <strong>Policy Type</strong> Filter then select the filtered result, you&#39;ll need to do this for each of the policies below:</p><ol><li><code>AmazonEC2ContainerRegistryFullAccess</code></li><li><code>AmazonEC2ContainerServiceFullAccess</code></li><li><code>AmazonEC2ContainerServiceRole</code></li></ol><p>After clearing the filter you should see 3 Policies selected, then click <strong>Attach Policy</strong> to add them to the User.</p><p><img src="https://docs.servicestack.net/images/aws/ecs/user-03.png" alt=""></p><p>As the names were cropped in the previous screen, double-check that you have the same policy names selected below:</p><p><img src="https://docs.servicestack.net/images/aws/ecs/user-04.png" alt=""></p><h2 id="checkout-aws-container-service" tabindex="-1">Checkout AWS Container Service <a class="header-anchor" href="#checkout-aws-container-service" aria-hidden="true">#</a></h2><p>This point is a good time to check out the <strong>EC2 Container Service</strong> by clicking on it in the AWS dashboard or following the direct link: <a href="https://console.aws.amazon.com/ecs/home" target="_blank" rel="noopener noreferrer">https://console.aws.amazon.com/ecs/home</a></p><p>We&#39;re not going to do anything within ECS just yet other than observe its emptiness \u{1F603} The first time you go there you&#39;ll be presented with the splash page below which you can skip on through by clicking <strong>Get Started</strong>:</p><p><img src="https://docs.servicestack.net/images/aws/ecs/ecs-01.png" alt=""></p><p>In the next screen AWS will try to guide you into populating your ECS Service with something, but as we&#39;re after a blank slate, you&#39;ll want to click <strong>Cancel</strong>:</p><p><img src="https://docs.servicestack.net/images/aws/ecs/ecs-02.png" alt=""></p><p>Which will arrive us to our destination - the empty state:</p><p><img src="https://docs.servicestack.net/images/aws/ecs/ecs-03.png" alt=""></p><p>But we needn&#39;t worry, everything in our ECS Service will be created outside ECS by our <strong>new EC2 Instance</strong> and <strong>Travis CI</strong> builds.</p><h2 id="_3-launch-new-ec2-docker-server-instance" tabindex="-1">3. Launch new EC2 Docker Server Instance <a class="header-anchor" href="#_3-launch-new-ec2-docker-server-instance" aria-hidden="true">#</a></h2><p>At this point we now have everything we need to light up the bits where our Docker Apps will run on. We want any EC2 Instances in the Container Service to use the purpose-specific <strong>Amazon ECS-Optimized Amazon Linux AMI</strong> which you can quickly find by selecting the <strong>AWS Marketplace</strong> tab and adding <code>ecs-optimized</code> in the filter then click <strong>Select</strong> on the first Amazon AMI result:</p><p><img src="https://docs.servicestack.net/images/aws/ecs/launch-01.png" alt=""></p><p>Which will start the Launch Instance Wizard where you can select the Instance Type you want to run. The <strong>t2.micro</strong> is more than enough for what we need but you can select any preferred Instance Type then click <strong>Next: Configure instance Details</strong>:</p><p><img src="https://docs.servicestack.net/images/aws/ecs/launch-02.png" alt=""></p><p>The important option in the <strong>Configure Instance Details</strong> screen is to select the <code>ecsInstanceRole</code> for the EC2 Instance&#39;s <strong>IAM Role</strong>, you&#39;ll also want to choose <code>Enable</code> for the <strong>Auto-assign Public IP</strong> option (if it&#39;s not already the default):</p><p><img src="https://docs.servicestack.net/images/aws/ecs/launch-03.png" alt=""></p><p>You can skip past the defaults on the <strong>Add Storage</strong> screen, in the <strong>Tag Instance</strong> screen you&#39;ll be able to assign a human-friendly label to identify this instance, e.g:</p><p><img src="https://docs.servicestack.net/images/aws/ecs/launch-04.png" alt=""></p><p>The <strong>Configure Security Group</strong> page is where you specify the ports you want open. You&#39;ll want <strong>SSH</strong> open so you can login to your instance and for Web Apps you&#39;ll also typically want <strong>HTTP</strong> and <strong>HTTPS</strong> open as well. With the warning message AWS is encouraging you to limit your SSH access to a limited IP Range which if you have a <strong>static IP</strong> from your ISP is a good idea to lock down the <strong>Source</strong> to <code>My IP</code>, otherwise leaving it open to any IP is ok as we&#39;ll be using a Private Key to login to our Instance.</p><p><img src="https://docs.servicestack.net/images/aws/ecs/launch-05.png" alt=""></p><p>On the next page you want to either create a new Public/Private Key Pair or use an existing one. If creating a new Pair you need to click <strong>Download Key Pair</strong> as you&#39;ll need it to SSH into your instance.</p><p><img src="https://docs.servicestack.net/images/aws/ecs/launch-06.png" alt=""></p><p>After clicking <strong>Launch Instances</strong> you&#39;ll be redirected to your EC2 <strong>Instances</strong> tab where you can watch your new Instance start up:</p><p><img src="https://docs.servicestack.net/images/aws/ecs/launch-07.png" alt=""></p><h2 id="revisit-aws-container-service" tabindex="-1">Revisit AWS Container Service <a class="header-anchor" href="#revisit-aws-container-service" aria-hidden="true">#</a></h2><p>Once <strong>running</strong> go back and refresh your <strong>EC2 Container Service</strong> page where you should now see a <strong>default</strong> cluster that was created:</p><p><img src="https://docs.servicestack.net/images/aws/ecs/ecs-04.png" alt=""></p><p>Clicking on <strong>ECS Instances</strong> tab will show your new Instance with an <strong>ACTIVE</strong> state:</p><p><img src="https://docs.servicestack.net/images/aws/ecs/ecs-05.png" alt=""></p><p>If you don&#39;t see a <strong>default</strong> cluster created with your new Instance attached, terminate your Instance then go back and create it again, triple-checking it has the <code>ecsInstanceRole</code> <strong>IAM Role</strong> when Configuring the Instance. If that fails, try re-creating the <code>ecsInstanceRole</code> ROLE making sure it has the <code>AmazonEC2ContainerServiceforEC2Role</code> Policy.</p><h2 id="_4-associating-elastic-ip-to-new-ec2-instance" tabindex="-1">4. Associating Elastic IP to new EC2 Instance <a class="header-anchor" href="#_4-associating-elastic-ip-to-new-ec2-instance" aria-hidden="true">#</a></h2><p>Before connecting to the Instance lets assign it a domain name so it has a canonical reference to make it easier to remember and refer to later. Before doing this you should assign your instance an <strong>Elastic IP</strong> so it has a <strong>persistent Public IP</strong> within your control that you can assign a domain name to.</p><p>To do this, click on the <strong>Elastic IPs</strong> tab then click on <strong>Allocate New Address</strong>, this will issue you a new <strong>Elastic IP</strong> that you can assign to your new instance, e.g:</p><p><img src="https://docs.servicestack.net/images/aws/ecs/elasticip-01.png" alt=""></p><p>After clicking <strong>Associate</strong> it will show up in the <strong>Elastic IPs</strong> tab:</p><p><img src="https://docs.servicestack.net/images/aws/ecs/elasticip-02.png" alt=""></p><h2 id="assign-a-domain-name-to-your-elastic-ip" tabindex="-1">Assign a Domain Name to your Elastic IP <a class="header-anchor" href="#assign-a-domain-name-to-your-elastic-ip" aria-hidden="true">#</a></h2><p>This is going to different for each Domain Registrar but you&#39;ll want to assign a new <strong>A Record</strong> to point to your new <strong>Elastic IP</strong>. If you&#39;re using Google Domains you can refer to their <a href="https://support.google.com/domains/answer/3290309?hl=en&amp;ref_topic=3251230" target="_blank" rel="noopener noreferrer">Google Domains Help Documentation</a>.</p><p>For the purposes of this tutorial we&#39;ve used the <code>ecsdemo.netcore.io</code> domain name which resolves to our <strong>Elastic IP</strong> Address.</p><h2 id="_5-log-into-the-new-ec2-instance" tabindex="-1">5. Log into the new EC2 Instance <a class="header-anchor" href="#_5-log-into-the-new-ec2-instance" aria-hidden="true">#</a></h2><p>With the new Instance up and running we can login to it, but you&#39;ll need access to a <code>ssh</code> client to make that happen. If you&#39;re fortunate to have a Unix-based OS at your disposal you&#39;re already set, if you&#39;re on Windows 10 you can enable <a href="https://msdn.microsoft.com/en-us/commandline/wsl/about" target="_blank" rel="noopener noreferrer">Bash on Ubuntu on Windows</a> otherwise you&#39;ll need to install a <a href="http://www.putty.org/" target="_blank" rel="noopener noreferrer">SSH Client for Windows</a>.</p><p>When you&#39;re ready open a Terminal and copy the <strong>EC2 Instance Key Pair</strong> that you downloaded previously and copy it into a permanent location, e.g <code>~/pem/ecs-demo.pem</code>.</p><p>Before we can SSH with the Private Key we need to lock down the permissions so only we can read it which you can do with:</p><div class="language-bash"><pre><code>$ <span class="token function">chmod</span> <span class="token number">400</span> ~/pem/ecs-demo.pem
</code></pre></div><p>Once locked down you can use it to SSH into your instance using the <code>-i</code> flag, logging in as the <code>ec2-user</code>:</p><div class="language-bash"><pre><code>$ <span class="token function">ssh</span> -i ~/pem/ecs-demo.pem ec2-user@ecsdemo.netcore.io
</code></pre></div><p>Replace <code>ecsdemo.netcore.io</code> with your domain name or Elastic IP. If everything went to plan you should now be logged into your EC2 Instance:</p><p><img src="https://docs.servicestack.net/images/aws/ecs/ssh-01.png" alt=""></p><p>We&#39;re only assigned one task while we&#39;re here which is to run an instance of the <code>jwilder/nginx-proxy</code> Docker App copying the command below:</p><div class="language-bash"><pre><code>$ docker run -d -p <span class="token number">80</span>:80 -v /var/run/docker.sock:/tmp/docker.sock:ro jwilder/nginx-proxy
</code></pre></div><p>This will pull the <a href="https://hub.docker.com/r/jwilder/nginx-proxy/" target="_blank" rel="noopener noreferrer">jwilder/nginx-proxy</a> Docker Image from <a href="https://hub.docker.com/explore/" target="_blank" rel="noopener noreferrer">Dockers public repository</a> which sets up a new Docker container running <a href="https://nginx.org/en/" target="_blank" rel="noopener noreferrer">nginx</a> and <a href="https://github.com/jwilder/docker-gen" target="_blank" rel="noopener noreferrer">docker-gen</a> which is what will enable our no-touch deployments where it will generate the reverse proxy configs for nginx each time a new Docker App is deployed where it will use its <code>VIRTUAL_HOST</code> Environment Variable that it was created with.</p><p>It&#39;s not important to <a href="http://jasonwilder.com/blog/2014/03/25/automated-nginx-reverse-proxy-for-docker/" target="_blank" rel="noopener noreferrer">know exactly how it works</a> only that it&#39;s responsible for setting up <strong>nginx</strong> to <strong>reverse proxy requests</strong> from our App&#39;s custom <code>VIRTUAL_HOST</code> (e.g. <a href="http://ecsdemo.netcore.io" target="_blank" rel="noopener noreferrer">ecsdemo.netcore.io</a>) to our .NET Core Kestrel HTTP Server that&#39;s listening on port <strong>5000</strong>.</p><p>If successful you&#39;ll get an output similar to:</p><p><img src="https://docs.servicestack.net/images/aws/ecs/ssh-02.png" alt=""></p><p>For the curious you can run <code>docker ps</code> at this point to see the running Docker Containers which should include this <strong>nginx-proxy</strong> and AWS&#39;s ECS agent.</p><h3 id="enable-support-for-ssl" tabindex="-1">Enable support for SSL <a class="header-anchor" href="#enable-support-for-ssl" aria-hidden="true">#</a></h3><p>If you wanted to host any of your Apps under SSL you&#39;ll instead need to run your <code>jwilder/nginx-proxy</code> container with:</p><div class="language-bash"><pre><code>$ docker run --detach --name nginx-proxy --publish <span class="token number">80</span>:80 --publish <span class="token number">443</span>:443 <span class="token punctuation">\\</span>
    --volume /etc/nginx/certs --volume /etc/nginx/vhost.d --volume /usr/share/nginx/html <span class="token punctuation">\\</span>
    --volume /var/run/docker.sock:/tmp/docker.sock:ro jwilder/nginx-proxy
</code></pre></div><p>You&#39;ll also need to run the <a href="https://github.com/JrCs/docker-letsencrypt-nginx-proxy-companion" target="_blank" rel="noopener noreferrer">letsencrypt-nginx-proxy-companion</a> companion Docker container for <code>nginx-proxy</code> with:</p><div class="language-bash"><pre><code>$ docker run --detach --name nginx-proxy-letsencrypt --volumes-from nginx-proxy <span class="token punctuation">\\</span>
    --volume /var/run/docker.sock:/var/run/docker.sock:ro jrcs/letsencrypt-nginx-proxy-companion
</code></pre></div><p>SSL Requires additional info added via environment variables included your .NET Core Docker App&#39;s deployment script which are documented in <a href="#configure-support-for-ssl">Configure support for SSL</a>.</p><h2 id="_6-fork-redis-geo-demo" tabindex="-1">6. Fork redis-geo Demo <a class="header-anchor" href="#_6-fork-redis-geo-demo" aria-hidden="true">#</a></h2><p>With all the prep work for setting up our Docker Server out of the way, we can now get to the fun part of deploying Docker Apps to it. Let&#39;s get started by forking the existing <a href="https://github.com/NetCoreApps/redis-geo" target="_blank" rel="noopener noreferrer">https://github.com/NetCoreApps/redis-geo</a> project:</p><p><img src="https://docs.servicestack.net/images/aws/ecs/fork-01.png" alt=""></p><p>This will create our own fork of the <code>redis-geo</code> Github project into our own Github User Account. We then need to <strong>Clone</strong> our local fork which we can do from the <a href="https://desktop.github.com/" target="_blank" rel="noopener noreferrer">Github Desktop App</a> to a local folder:</p><p><img src="https://docs.servicestack.net/images/aws/ecs/fork-02.png" alt=""></p><h3 id="inspect-the-build-scripts" tabindex="-1">Inspect the Build Scripts <a class="header-anchor" href="#inspect-the-build-scripts" aria-hidden="true">#</a></h3><p>Lets open the folder in VS code to inspect what deployment scripts we have:</p><div class="language-bash"><pre><code>C:<span class="token punctuation">\\</span>src<span class="token punctuation">\\</span>redis-geo<span class="token operator">&gt;</span>code <span class="token builtin class-name">.</span>
</code></pre></div><p>The <code>.travis.yml</code> is used to configure the environment which <strong>Travis CI</strong> will execute your build under. Here we&#39;re telling Travis we want a <strong>csharp</strong> environment for our solution located at <strong>src/RedisGeo.sln</strong> using an Ubuntu 14.04 Linux distribution with .NET Core installed. The <strong>script</strong> section tells Travis how it should build our project, which is to just run the build scripts in the repo:</p><p><img src="https://docs.servicestack.net/images/aws/ecs/code-01.png" alt=""></p><p>The <code>DockerFile</code> tells Docker how to build our Docker App Image:</p><ul><li>that&#39;s based on the <strong>microsoft/dotnet:latest</strong> Docker Image from Docker&#39;s public Repository</li><li>includes a copy of our .NET Core solution files</li><li>runs <code>dotnet restore</code> on to pull down all NuGet dependencies</li><li>builds the .NET Core Solutions <strong>Host Project</strong> using <code>dotnet build</code></li><li>notifies Docker our App will run a TCP Service listening on port <code>5000</code> that it should expose</li><li>sets the <code>ASPNETCORE_URLS</code> Environment Variable</li><li>tells Docker what to execute when our App is run</li></ul><p>This is a fairly generic template for building a .NET Core multi-project App which typically only requires changing the <strong>WORKDIR</strong> to point to your Solutions <strong>Host Project</strong>:</p><p><img src="https://docs.servicestack.net/images/aws/ecs/code-02.png" alt=""></p><p>The primary config changes you&#39;ll need to make are in <code>/deploy-env.sh</code> which contains public deployment and project-specific info. Here you&#39;ll want to change <code>AWS_DEFAULT_REGION</code> with the AWS region where your ECS Service is located. You&#39;ll also need to change <code>AWS_VIRTUAL_HOST</code> with your <code>VIRTUAL_HOST</code>:</p><p><img src="https://docs.servicestack.net/images/aws/ecs/code-03.png" alt=""></p><h3 id="ecs-task-definition-json" tabindex="-1">ECS task-definition.json <a class="header-anchor" href="#ecs-task-definition-json" aria-hidden="true">#</a></h3><p>The <code>task-definition.json</code> is specific to AWS ECS which lets you declaratively define an atomic collection of Docker Containers ECS should run when it deploys this &quot;Task&quot;. It&#39;s essentially a thin wrapper around <a href="https://docs.docker.com/engine/reference/run/" target="_blank" rel="noopener noreferrer">docker run</a> where most features can be easily mapped to its command-line switches.</p><p>The <code>task-definition.json</code> is where we tell ECS what Docker Containers our App needs. Here in addition to our Docker App we also need an instance of <code>redis:3.2</code> that&#39;s made available to our App via Docker&#39;s <code>--link</code> feature which lets us connect to the redis-server instance using the <code>ecsdemo-redisgeo-redis</code> Hostname that we make available to our App via the <code>REDIS_HOST</code> Environment variable:</p><p><img src="https://docs.servicestack.net/images/aws/ecs/code-04.png" alt=""></p><h2 id="configure-support-for-ssl" tabindex="-1">Configure support for SSL <a class="header-anchor" href="#configure-support-for-ssl" aria-hidden="true">#</a></h2><p>If you want to host your .NET Core Apps under SSL you&#39;ll need to include some additional information in your deployment scripts that will be passed to the <a href="https://github.com/JrCs/docker-letsencrypt-nginx-proxy-companion" target="_blank" rel="noopener noreferrer">docker-letsencrypt-nginx-proxy-companion</a> container which is a run as a companion Docker container to <a href="https://github.com/jwilder/nginx-proxy" target="_blank" rel="noopener noreferrer">nginx-proxy</a> which will automate the creation/renewal of Lets Encrypt SSL Certificates and the necessary nginx configuration to redirect HTTP Requests to SSL Requests which are &quot;SSL terminated&quot; at the nginx reverse proxy and proxied as HTTP to your downstream .NET Core App.</p><p>Instead of starting with <code>redis-geo</code> you&#39;ll want to start with the deployment scripts in <a href="https://github.com/ServiceStack/sharpscript" target="_blank" rel="noopener noreferrer">/ServiceStack/sharpscript</a> which contain a working example of a .NET Core App hosted under SSL at <a href="https://sharpscript.net" target="_blank" rel="noopener noreferrer">https://sharpscript.net</a>.</p><p>Essentially your <a href="https://github.com/ServiceStack/sharpscript/blob/master/deploy-envs.sh" target="_blank" rel="noopener noreferrer">deploy-envs.sh</a> deployment configuration script needs to include <code>LETSENCRYPT_HOST</code> and <code>LETSENCRYPT_EMAIL</code> variables:</p><div class="language-bash"><pre><code><span class="token shebang important">#!/bin/bash</span>

<span class="token comment"># set environment variables used in deploy.sh and AWS task-definition.json:</span>
<span class="token builtin class-name">export</span> <span class="token assign-left variable">IMAGE_NAME</span><span class="token operator">=</span>netcoreapps-sharpscript
<span class="token builtin class-name">export</span> <span class="token assign-left variable">IMAGE_VERSION</span><span class="token operator">=</span>latest

<span class="token builtin class-name">export</span> <span class="token assign-left variable">AWS_DEFAULT_REGION</span><span class="token operator">=</span>us-east-1
<span class="token builtin class-name">export</span> <span class="token assign-left variable">AWS_ECS_CLUSTER_NAME</span><span class="token operator">=</span>default
<span class="token builtin class-name">export</span> <span class="token assign-left variable">AWS_VIRTUAL_HOST</span><span class="token operator">=</span>sharpscript.net
<span class="token builtin class-name">export</span> <span class="token assign-left variable">LETSENCRYPT_HOST</span><span class="token operator">=</span><span class="token variable">$AWS_VIRTUAL_HOST</span>
<span class="token builtin class-name">export</span> <span class="token assign-left variable">LETSENCRYPT_EMAIL</span><span class="token operator">=</span>team@servicestack.net
</code></pre></div><p>The only other change required is to pass these environment variables to your App&#39;s Docker container defined in <a href="https://github.com/ServiceStack/sharpscript/blob/master/scripts/task-definition.json" target="_blank" rel="noopener noreferrer">task-definition.json</a>:</p><div class="language-json"><pre><code><span class="token punctuation">{</span>
    <span class="token property">&quot;family&quot;</span><span class="token operator">:</span> <span class="token string">&quot;\${ECS_TASK}&quot;</span><span class="token punctuation">,</span>
    <span class="token property">&quot;networkMode&quot;</span><span class="token operator">:</span> <span class="token string">&quot;bridge&quot;</span><span class="token punctuation">,</span>
    <span class="token property">&quot;containerDefinitions&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span>
        <span class="token punctuation">{</span>
            <span class="token property">&quot;image&quot;</span><span class="token operator">:</span> <span class="token string">&quot;\${AWS_ECS_REPO_DOMAIN}/\${IMAGE_NAME}:\${IMAGE_VERSION}&quot;</span><span class="token punctuation">,</span>
            <span class="token property">&quot;name&quot;</span><span class="token operator">:</span> <span class="token string">&quot;\${IMAGE_NAME}&quot;</span><span class="token punctuation">,</span>
            <span class="token property">&quot;cpu&quot;</span><span class="token operator">:</span> <span class="token number">128</span><span class="token punctuation">,</span>
            <span class="token property">&quot;memory&quot;</span><span class="token operator">:</span> <span class="token number">256</span><span class="token punctuation">,</span>
            <span class="token property">&quot;essential&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
            <span class="token property">&quot;portMappings&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span>
                <span class="token punctuation">{</span>
                    <span class="token property">&quot;containerPort&quot;</span><span class="token operator">:</span> <span class="token number">5000</span><span class="token punctuation">,</span>
                    <span class="token property">&quot;hostPort&quot;</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
                    <span class="token property">&quot;protocol&quot;</span><span class="token operator">:</span> <span class="token string">&quot;tcp&quot;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">]</span><span class="token punctuation">,</span>
            <span class="token property">&quot;environment&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span>
                <span class="token punctuation">{</span>
                    <span class="token property">&quot;name&quot;</span><span class="token operator">:</span> <span class="token string">&quot;VIRTUAL_HOST&quot;</span><span class="token punctuation">,</span>
                    <span class="token property">&quot;value&quot;</span><span class="token operator">:</span> <span class="token string">&quot;\${AWS_VIRTUAL_HOST}&quot;</span>
                <span class="token punctuation">}</span><span class="token punctuation">,</span>
                <span class="token punctuation">{</span>
                    <span class="token property">&quot;name&quot;</span><span class="token operator">:</span> <span class="token string">&quot;LETSENCRYPT_HOST&quot;</span><span class="token punctuation">,</span>
                    <span class="token property">&quot;value&quot;</span><span class="token operator">:</span> <span class="token string">&quot;\${LETSENCRYPT_HOST}&quot;</span>
                <span class="token punctuation">}</span><span class="token punctuation">,</span>
                <span class="token punctuation">{</span>
                    <span class="token property">&quot;name&quot;</span><span class="token operator">:</span> <span class="token string">&quot;LETSENCRYPT_EMAIL&quot;</span><span class="token punctuation">,</span>
                    <span class="token property">&quot;value&quot;</span><span class="token operator">:</span> <span class="token string">&quot;\${LETSENCRYPT_EMAIL}&quot;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">]</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Otherwise all other deployment scripts remain the same as a normal ECS .NET Core Docker App, the primary difference being that after it&#39;s deployed by AWS ECS, it triggers the nginx-proxy-companion to retrieve and auto-configure an SSL Certificate from <a href="https://letsencrypt.org" target="_blank" rel="noopener noreferrer">Lets Encrypt</a> for the App&#39;s external domain defined in <code>LETSENCRYPT_HOST</code> which it registers with nginx to enable its SSL-terminated <code>https</code> support for that domain.</p><h2 id="create-project-in-travis-ci" tabindex="-1">Create project in Travis-CI <a class="header-anchor" href="#create-project-in-travis-ci" aria-hidden="true">#</a></h2><p>After making the necessary changes in <code>/deploy-env.sh</code> we can register our project in <strong>Travis CI</strong>, fortunately for us Travis&#39;s UX is streamlined making this effortless. Start by clicking on <strong>Sign Up</strong> button on Travis&#39;s home page <a href="https://travis-ci.org" target="_blank" rel="noopener noreferrer">https://travis-ci.org</a>:</p><p><img src="https://docs.servicestack.net/images/aws/ecs/travis-01.png" alt=""></p><p>Then click on the <code>+</code> link next to <strong>My Repositories</strong>:</p><p><img src="https://docs.servicestack.net/images/aws/ecs/travis-02.png" alt=""></p><p>This takes you to your Github Profile view where you just need to click on the the switch icon next to your <strong>redis-geo fork</strong>, e.g:</p><p><img src="https://docs.servicestack.net/images/aws/ecs/travis-03.png" alt=""></p><h3 id="ci-environment-variables" tabindex="-1">CI Environment Variables <a class="header-anchor" href="#ci-environment-variables" aria-hidden="true">#</a></h3><p>After enabling your project it will appear in your repositories list. Here we need to click on the <strong>Settings</strong> Menu Item in the <strong>More Options</strong> drop down menu in order to provide Travis the sensitive <code>ecsDemoUser</code> credentials that we don&#39;t want to include in a public Github Repository. At a minimum you&#39;ll need to add Environment variables for the <code>ecsDemoUser</code> IAM User you copied above:</p><ul><li><code>AWS_ACCOUNT_NUMBER</code></li><li><code>AWS_ACCESS_KEY_ID</code></li><li><code>AWS_SECRET_ACCESS_KEY</code></li></ul><p>The <strong>Settings</strong> page is where you can define any sensitive information you want your Docker App to have access to. E.g. although it&#39;s not needed for this Demo you can specify your <code>SERVICESTACK_LICENSE</code> here where its inject into your Docker App with the <strong>&quot;environment&quot;</strong> Key/Value list in your projects <code>task-definition.json</code>. If your App requires a lot of confidential information it can be easier to instead register a connection string to a <a href="https://docs.servicestack.net/appsettings" target="_blank" rel="noopener noreferrer">Remote AppSettings data source</a>, that way you can have a centralized location for managing the keys and connection strings for all your Apps.</p><p><img src="https://docs.servicestack.net/images/aws/ecs/travis-04.png" alt=""></p><p>If it&#39;s not on hand, you can get the <code>AWS_ACCOUNT_NUMBER</code> for your <code>ecsDemoUser</code> from the number embedded in its <strong>User ARN</strong>:</p><p><img src="https://docs.servicestack.net/images/aws/ecs/travis-05.png" alt=""></p><p>After adding your <code>ecsDemoUser</code> credentials above, commit and push your changes to <code>deploy-env.sh</code> in order to trigger a new <strong>Travis CI</strong> build. If you&#39;ve previously committed the changes you can click <strong>Restart build</strong> to rerun the build using your latest Environment Variables. This will trigger a new build which if everything is in place should result in a successful green build:</p><p><img src="https://docs.servicestack.net/images/aws/ecs/travis-06.png" alt=""></p><h2 id="inspect-aws-container-service" tabindex="-1">Inspect AWS Container Service <a class="header-anchor" href="#inspect-aws-container-service" aria-hidden="true">#</a></h2><p>Now we can go back into <strong>EC2 Container Service</strong> and have a look at what the generic <code>deploy.sh</code> script created for us. Clicking the <strong>Repositories</strong> tab will display your Apps <a href="http://docs.aws.amazon.com/AmazonECS/latest/developerguide/ECS_Console_Repositories.html" target="_blank" rel="noopener noreferrer">private ECR Repository</a> which contains a list of all Docker Images that were deployed to ECS with the one that&#39;s currently used by the running Docker Container, tagged with the <strong>latest</strong> Image tag:</p><p><img src="https://docs.servicestack.net/images/aws/ecs/ecs-06.png" alt=""></p><p>In the <strong>Clusters</strong> tab you&#39;ll see that your <strong>default</strong> Cluster contains an <a href="http://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs_services.html" target="_blank" rel="noopener noreferrer">ECS Service</a> aptly named <code>ecsdemo-redisgeo-service</code>:</p><p><img src="https://docs.servicestack.net/images/aws/ecs/ecs-07.png" alt=""></p><p>The <a href="http://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs_services.html" target="_blank" rel="noopener noreferrer">ECS Service</a> is what manages your running Tasks where if your Docker App goes down for whatever reason, the Service will restart new Task Instances based on its <a href="http://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_defintions.html" target="_blank" rel="noopener noreferrer">Task Definition</a> until the <strong>Desired count</strong> of instances is reached.</p><p><img src="https://docs.servicestack.net/images/aws/ecs/ecs-08.png" alt=""></p><h3 id="view-list-of-running-docker-containers" tabindex="-1">View list of running Docker Containers <a class="header-anchor" href="#view-list-of-running-docker-containers" aria-hidden="true">#</a></h3><p>If your Service contains a <strong>RUNNING</strong> Task that means your time here was a success. We can further verify that&#39;s everything&#39;s in order by SSH&#39;ing back into our EC2 Instance and running <code>docker ps</code> to see our running Docker Containers:</p><p><img src="https://docs.servicestack.net/images/aws/ecs/ssh-03.png" alt=""></p><p>Where we should see <strong>4 running</strong> Docker Containers:</p><ol><li>nginx-proxy</li><li>Our .NET Core Docker App</li><li>redis-server</li><li>AWS ECS agent</li></ol><h2 id="problems-with-the-task-not-running" tabindex="-1">Problems with the task not running <a class="header-anchor" href="#problems-with-the-task-not-running" aria-hidden="true">#</a></h2><p>If you don&#39;t have a <strong>RUNNING</strong> Task then you might need to <a href="http://docs.aws.amazon.com/AmazonECS/latest/developerguide/troubleshooting.html" target="_blank" rel="noopener noreferrer">restart the ECS container agent</a> by SSH&#39;ing into the EC2 Instance and running the commands below:</p><div class="language-"><pre><code>[ec2-user ~]$ sudo stop ecs
ecs stop/waiting
[ec2-user ~]$ sudo start ecs
ecs start/running, process 26119
</code></pre></div><p>If that still doesn&#39;t work you should see if any of the containers are stopping shortly after they have started. A good way of doing this is to run <code>docker ps -a</code> which will show you all the containers that have started (without the -a, it only shows the currently running ones). If you see that some are exiting with a code that is not 0, then you may have a problem with that container. Run that container using <code>docker run</code> using its image name and omitting the -d flag. For example:</p><div class="language-"><pre><code>docker run 473481601643.dkr.ecr.ap-southeast-2.amazonaws.com/netcoreapps-redisgeo:latest
</code></pre></div><p>That will run the container and show its output, which might give you some indication of the problem.</p><h2 id="_8-play-your-deployed-net-core-docker-app" tabindex="-1">8. Play your deployed .NET Core Docker App! <a class="header-anchor" href="#_8-play-your-deployed-net-core-docker-app" aria-hidden="true">#</a></h2><p>With all the pieces in place we can visit our virtual host <a href="http://redisgeo.netcore.io" target="_blank" rel="noopener noreferrer">http://ecsdemo.netcore.io</a> to see the fruits of our Labor - our .NET Core Docker App, alive!</p><p><a href="http://redisgeo.netcore.io" target="_blank" rel="noopener noreferrer"><img src="https://docs.servicestack.net/images/aws/ecs/app-01.png" alt=""></a></p><h2 id="things-to-try" tabindex="-1">Things to try <a class="header-anchor" href="#things-to-try" aria-hidden="true">#</a></h2><h3 id="_1-make-a-change-to-your-app" tabindex="-1">1. Make a change to your App <a class="header-anchor" href="#_1-make-a-change-to-your-app" aria-hidden="true">#</a></h3><p>With your .NET Core Docker mission officially a success the first thing you&#39;re going to want to do is to commit a change to your fork whilst watching your <strong>Travis CI</strong> bot working away so you can see your Continuous Docker deployments in action \u{1F603}</p><h3 id="_2-go-through-this-tutorial-again" tabindex="-1">2. Go through this tutorial again <a class="header-anchor" href="#_2-go-through-this-tutorial-again" aria-hidden="true">#</a></h3><p>If you&#39;ve stuttered hazily through parts of this tutorial we recommend going through it again from scratch as things should become a lot clearer and faster the next time around. After doing this a few times everything will appear intuitive and you won&#39;t need to refer to this tutorial again.</p><h3 id="_3-copy-the-build-scripts-to-dockerize-own-net-core-apps" tabindex="-1">3. Copy the build scripts to Dockerize own .NET Core Apps <a class="header-anchor" href="#_3-copy-the-build-scripts-to-dockerize-own-net-core-apps" aria-hidden="true">#</a></h3><p>Customizing the deploy scripts to your own Apps will help familiarize yourself with Docker and identify the areas which are customizable.</p><h3 id="_4-exec-build-scripts-to-create-and-run-your-docker-app-locally" tabindex="-1">4. Exec build scripts to Create and Run your Docker App locally <a class="header-anchor" href="#_4-exec-build-scripts-to-create-and-run-your-docker-app-locally" aria-hidden="true">#</a></h3><p>Install <a href="https://docs.docker.com/engine/installation/mac/" target="_blank" rel="noopener noreferrer">Docker for Mac</a> or <a href="https://docs.docker.com/engine/installation/windows/" target="_blank" rel="noopener noreferrer">Docker for Windows</a> and try building and running the Docker Images locally. Since you&#39;re running locally you&#39;ll need to set any required <strong>Travis CI</strong> Environment Variables then have a look at translating what ECS does with its <code>task-definition.json</code> into docker commands. This example is a little tricky due to the use of Docker&#39;s <code>--link</code> feature but with some trial and error and the <a href="https://docs.docker.com/engine/reference/run/" target="_blank" rel="noopener noreferrer">Docker run reference</a> to guide you, you&#39;ll have your Docker App running locally - acquainting you with one of Docker&#39;s killer features!</p>__VP_STATIC_END__`,186),a=[r];function i(c,p,l,h,d,u){return o(),t("div",null,a)}var k=e(s,[["render",i]]);export{m as __pageData,k as default};
